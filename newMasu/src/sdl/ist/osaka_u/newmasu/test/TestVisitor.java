package sdl.ist.osaka_u.newmasu.test;import org.eclipse.jdt.core.dom.*;import sdl.ist.osaka_u.newmasu.Finder.*;public class TestVisitor extends ASTVisitor {/*    @Override    public boolean visit(IfStatement s){        DefaultProcessor.get(s).process(s);        DefaultProcessor.get(s.getThenStatement());        return true;    }    @Override    public boolean visit(Block b){        DefaultProcessor.get(b).process(b);        return true;    }    @Override    public boolean visit(TypeDeclaration td){        DefaultProcessor.get(td).process(td);        return true;    }*/    /*    // あるクラス以下に含まれる変数宣言を列挙    private void tst4(TypeDeclaration node){        node.accept(new StatementVisitor());    }    private class StatementVisitor extends ASTVisitor {        @Override        public boolean visit(VariableDeclarationStatement node){            System.out.print(node.toString());  // toString()すると改行を含む            return true;        }    }    // ブロックを遡って，各ブロックに含まれるステートメントを表示    private void tst3(Block node){        List<Integer> target = new ArrayList<>();        target.add(ASTNode.BLOCK);        List<Block> res = SimpleFinder.getUpper(node,target);        Collections.reverse(res);        res.add(node);        for(Block b:res){            List<Statement> sts = b.statements();            int i=0;            for(Statement s: sts){                System.out.print( i + ":  " + s.toString() );                i++;            }        }        System.out.println("---------------------------------------------");    }    // ブロックを遡って表示する    private void tst2(Block node){        List<Integer> target = new ArrayList<>();        target.add(ASTNode.BLOCK);        List<Block> res = SimpleFinder.getUpper(node,target);        for(Block b:res){            System.out.println(b.getLength());        }        System.out.println("---------------------------------------------");    }    private void tst1(MethodDeclaration node){        List<ITypeBinding> res =                NodeFinder2.get( new NodeOrBinding(node), ASTNode.TYPE_DECLARATION,                        DelegateSample.getInherited(), DelegateSample.bindingNullJudge());        // print method        String paramStr = "";        List<SingleVariableDeclaration> param = node.parameters();        for( SingleVariableDeclaration p : param ){            paramStr += p.getType().toString() + " " + p.getName() + ", ";        }        System.out.println( node.getReturnType2().toString() + " " + node.getName() + "( " + paramStr + ")" );        // print classes        for( ITypeBinding b : res){            if( b.isInterface() )                System.out.print("interface ");            else if(b.isEnum())                System.out.print("enum ");            else                System.out.print("class ");            System.out.println(b.getName());        }        System.out.println("---------------------------------------------");    }*/    @Override    public boolean visit(CompilationUnit node){        System.out.println("-----------------------------");//        System.out.println(node.toString());        node.accept(new CFGSample());        return false;    }}